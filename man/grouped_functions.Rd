% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grouped_functions.R
\name{grouped_functions}
\alias{grouped_functions}
\alias{grouped_mean}
\alias{grouped_mode}
\alias{grouped_median}
\title{Estimate Measures of Central Tendency for Already Grouped Data}
\usage{
grouped_mean(frequencies, intervals, sep = NULL, trim = NULL)

grouped_mode(frequencies, intervals, sep = NULL, trim = NULL, method = 1)

grouped_median(frequencies, intervals, sep = NULL, trim = NULL)
}
\arguments{
\item{frequencies}{A vector of frequencies.}

\item{intervals}{A 2-column \code{matrix} with the same number of
rows as the length of frequencies, with the first column being
the lower class boundary, and the second column being the upper
class boundary. Alternatively, \code{intervals} may be a character
vector, and you may specify \code{sep} (and possibly, \code{trim}) to
have the function automatically create the required \code{matrix}.}

\item{sep}{Optional character that separates lower and uppper
class boundaries if \code{intervals} is entered as a character vector.}

\item{trim}{Optional leading or trailing characters to trim from
the character vector being used for \code{intervals}. There is an
in-built pattern to trim the breakpoint labels created by
\code{\link[base:cut]{base::cut()}}. If you are using a \verb{grouped_*} function on the
output of \code{cut} (where, for some reason, you no longer have
access to the original data), you can use \code{trim = "cut"}.}

\item{method}{A single value (1 or 2) determining which method
will be used to estimate the grouped mode. See the notes
section for the different approaches.}
}
\value{
A single numeric value representing the grouped mean,
median, or mode, depending on which function was called.
}
\description{
Estimates the mean, median, and mode of already grouped data
given the interval ranges and the frequencies of each group.
}
\details{
\subsection{Calculation of Grouped Mean}{

The following formula is used to calculate the grouped mean:

\deqn{M = \frac{\sum f\times x}{n}}{M = (sum f * x)/n}

Where:
\itemize{
\item f = The frequency of each class
\item x = The width of each class
\item n = The sum of the frequencies
}
}

\subsection{Calculation of Grouped Median}{

The following forumla is used to calculate the grouped median:

\deqn{M = L +\frac{\frac{n}{2}-cf}{f} \times c}{M = L + (n/2 - cf)/f * c}

Where:
\itemize{
\item L = The lower boundary of the median class
\item n = The sum of the frequencies
\item cf = The cumulative frequency of the class below the median class
\item f = The frequency of the median class
\item c = The length of the median class
}
}

\subsection{Calculation of Grouped Mode}{

The following formula is used to calculate the grouped mode if
\code{method = 1}:

\deqn{M = L + \left ( \frac{f1-f0}{\left ( 2 \times f1 \right ) - f0 - f2} \right ) \times c}{Z = L + ((f1 - f0) / (2 * f1 - f0 - f2)) * c}

Where:
\itemize{
\item L = The lower boundary of the mode class
\item f1 = The frequency of the mode class
\item f0 = The frequency of the class before the mode class
\item f2 = The frequency of the class after the mode class
\item c = The length of the mode class
}

Keep in mind that while it might be easy to say which is the modal
group, the mode of the source data may not even be in that group.
Additionally, it is possible for data to have more than one mode
or conversely, no mode.

The following formula is used to calculate the grouped mode if
\code{method = 2}:

\deqn{M = (3 \times x) - (2 \times y)}{M = (3 * x) - (2 * y)}

Where:
\itemize{
\item x = The group median
\item y = The group mean
}
}
}
\examples{

mydf <- structure(list(salary = c("1500-1600", "1600-1700", "1700-1800",
        "1800-1900", "1900-2000", "2000-2100", "2100-2200", "2200-2300",
        "2300-2400", "2400-2500"), number = c(110L, 180L, 320L, 460L,
        850L, 250L, 130L, 70L, 20L, 10L)), .Names = c("salary", "number"),
        class = "data.frame", row.names = c(NA, -10L))
mydf

with(mydf, grouped_median(frequencies = number, intervals = salary, sep = "-"))

## Example with intervals manually specified
Freq <- mydf$number
X <- cbind(c(1500, 1600, 1700, 1800, 1900, 2000, 2100, 2200, 2300, 2400),
           c(1600, 1700, 1800, 1900, 2000, 2100, 2200, 2300, 2400, 2500))

grouped_median(Freq, X)

# Using `cut`
set.seed(1)
x <- sample(100, 100, replace = TRUE)
y <- data.frame(table(cut(x, 10)))

with(y, grouped_mean(Freq, Var1, sep = ",", trim = "cut"))
mean(x)

with(y, grouped_median(Freq, Var1, sep = ",", trim = "cut"))
median(x)

## Note that the mode might be really far off depending on the approach used
with(y, grouped_mode(Freq, Var1, sep = ",", trim = "cut"))
with(y, grouped_mode(Freq, Var1, sep = ",", trim = "cut", method = 2))
tail(sort(table(x)))

}
